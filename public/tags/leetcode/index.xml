<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode on Canon Blog</title><link>/tags/leetcode/</link><description>Recent content in LeetCode on Canon Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 13 Mar 2022 11:42:55 +0000</lastBuildDate><atom:link href="/tags/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>正则表达式 消耗字符</title><link>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%B6%88%E8%80%97%E5%AD%97%E7%AC%A6/</link><pubDate>Sun, 13 Mar 2022 11:42:55 +0000</pubDate><guid>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%B6%88%E8%80%97%E5%AD%97%E7%AC%A6/</guid><description>正则表达式匹配过程 主要的引擎有2种: DFA(Deterministic Finite Automatons/确定性有限自动机—)，文本主导的正则引擎 NFA(Nondeterministic Finite Automatons/非确定性有限</description></item><item><title>Disjoint_set</title><link>/post/disjoint-set/</link><pubDate>Tue, 02 Feb 2021 23:56:57 +0000</pubDate><guid>/post/disjoint-set/</guid><description>template type unionFind struct { parent, rank []int } func newunionFind(n int) *unionFind { parent := make([]int, n) rank := make([]int, n) for i := range parent { parent[i] = i rank[i] = 1 } return &amp;amp;unionFind{parent, rank} } func (uf *unionFind) find(x int) int { if uf.parent[x] != x { uf.parent[x] = uf.find(uf.parent[x]) } return uf.parent[x] } func (uf *unionFind) union(x, y int) bool { fx, fy := uf.find(x),</description></item><item><title>最长上升子序列</title><link>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 15 Jun 2020 16:58:15 +0000</pubDate><guid>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid><description>理解最长上升子序列的二分法（题目 ） 首先我们要维护数组d[i]来记录当前符合上升子序列的所有下标，len表示上升子序列的长度，那么情况下len</description></item><item><title>链表反转</title><link>/post/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/</link><pubDate>Fri, 05 Jun 2020 14:11:28 +0000</pubDate><guid>/post/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/</guid><description>链表的反转的类型，就我目前做题的经历和情况来看，目前我一共遇到2种类型的链表反转，第一类是最简单的把整条链表反转，第二类就是把链表中的某一段</description></item></channel></rss>