<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on Canon Blog</title><link>/</link><description>Recent content in Home on Canon Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 10 May 2023 18:23:11 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Raft</title><link>/post/raft/</link><pubDate>Wed, 10 May 2023 18:23:11 +0000</pubDate><guid>/post/raft/</guid><description>etcd所使用的raft算法要点！ raft角色/状态 Leader: 领导者 Follower: 跟随者 Candidate: 候选人, 选举中的一个临时角色 选举 在一定时间内(ttl), followe</description></item><item><title>go sync/atomic</title><link>/post/sync-atomic/</link><pubDate>Tue, 18 Apr 2023 17:55:01 +0000</pubDate><guid>/post/sync-atomic/</guid><description>定义 原子操作是一种可以在不加锁的情况下，对内存数据进行读写的操作, 使用sync/atomic提供的原子操作可以确保在任意时刻只有一个goro</description></item><item><title>go runtime.SetFinalizer 用法</title><link>/post/runtime-setfinalizer/</link><pubDate>Sat, 18 Feb 2023 10:34:47 +0000</pubDate><guid>/post/runtime-setfinalizer/</guid><description>runtime.SetFinalizer可以在内存中对象被回收前(gc)，指定一些操作。 用法 document : https://pkg.go.dev/runtime#SetFinalizer //SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with</description></item><item><title>go http.transport</title><link>/post/go-http-transport/</link><pubDate>Sat, 10 Dec 2022 15:00:42 +0000</pubDate><guid>/post/go-http-transport/</guid><description>​ 理解一下golang标准库里面的net/http包中的client类型，但是其实client类型也是通过实现RoundTripper接口来</description></item><item><title>go slice</title><link>/post/go-slice/</link><pubDate>Wed, 06 Jul 2022 21:11:34 +0000</pubDate><guid>/post/go-slice/</guid><description>1、切片结构 一个切片由3部分组成：指针、长度和容量。指针指向底层数组，长度代表slice当前的长度，容量代表底层数组的长度，同时切片的长度可</description></item><item><title>linux tmpfs</title><link>/post/linux-tmpfs/</link><pubDate>Mon, 06 Jun 2022 12:07:21 +0000</pubDate><guid>/post/linux-tmpfs/</guid><description>​ tmpfs,临时文件系统，是一种基于内存的文件系统，它和虚拟磁盘ramdisk比较类似像，但不完全相同，和ramdisk一样，tmpfs可</description></item><item><title>go 如何实现线程安全（并发安全）的 map</title><link>/post/go-%E5%B9%B6%E5%8F%91map/</link><pubDate>Fri, 27 May 2022 11:02:08 +0000</pubDate><guid>/post/go-%E5%B9%B6%E5%8F%91map/</guid><description>在网上查了查如何实现线程安全（并发安全）的 map，发现了几种方法。 sync.RWMutex 加读写锁 //例子 type RWMap struct { // 一个读写锁保护的线程安全的map sync.RWMutex // 读写锁保护</description></item><item><title>go map 存储方法</title><link>/post/go-map-save-and-use-func/</link><pubDate>Sat, 16 Apr 2022 11:51:57 +0000</pubDate><guid>/post/go-map-save-and-use-func/</guid><description>背景 最近在公司重构个系统的时候，由于某一个流程需要按需来自定义功能来进行处理，于是我想着用一个map来做一个映射关系，然后在这个流程中利用一</description></item><item><title>CommonJS, AMD and RequireJS</title><link>/post/commonjs-amd-and-requirejs/</link><pubDate>Wed, 06 Apr 2022 11:37:48 +0000</pubDate><guid>/post/commonjs-amd-and-requirejs/</guid><description>最近在使用typescript写一点小脚本，再用tsc编译成js文件后，使用node运行发现报错，再转去看一眼编译出来的js文件，发现不对劲</description></item><item><title>正则表达式 消耗字符</title><link>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%B6%88%E8%80%97%E5%AD%97%E7%AC%A6/</link><pubDate>Sun, 13 Mar 2022 11:42:55 +0000</pubDate><guid>/post/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%B6%88%E8%80%97%E5%AD%97%E7%AC%A6/</guid><description>正则表达式匹配过程 主要的引擎有2种: DFA(Deterministic Finite Automatons/确定性有限自动机—)，文本主导的正则引擎 NFA(Nondeterministic Finite Automatons/非确定性有限</description></item><item><title>linux F-RTO</title><link>/post/linux-f-rto/</link><pubDate>Fri, 28 Jan 2022 11:51:01 +0000</pubDate><guid>/post/linux-f-rto/</guid><description>F-RTO 全称 Forward RTO-Recovery，一种检测TCP的虚假超时重传的算法。目的是判断RTO是否正常，从而决定是否执行拥塞避免算法 rfc5682: It has been pointed out that the</description></item><item><title>Go 基础知识点</title><link>/post/go-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</link><pubDate>Sun, 12 Sep 2021 15:49:10 +0000</pubDate><guid>/post/go-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</guid><description>记录一下golang的基础要点，以方便后续复习 GC 标记清除 ​ 标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式</description></item><item><title>EVPN</title><link>/post/evpn/</link><pubDate>Sun, 16 May 2021 16:36:37 +0000</pubDate><guid>/post/evpn/</guid><description>最初的VXLAN方案（RFC7348）中没有定义控制平面，是手工配置VXLAN隧道，然后通过流量泛洪的方式进行主机地址的学习。这种方式实现上</description></item><item><title>Linux virtual devices</title><link>/post/linux-virtual-devices/</link><pubDate>Thu, 15 Apr 2021 15:34:10 +0000</pubDate><guid>/post/linux-virtual-devices/</guid><description>Linux virtual devices Type Bridge、Veth、Tun、Tap Linux namespace namespace的本质就是指：一种在空间上隔离的概念，当下盛行的许多容器虚拟化技术（典型</description></item><item><title>linux cgroup</title><link>/post/linux-cgroup/</link><pubDate>Tue, 13 Apr 2021 15:34:10 +0000</pubDate><guid>/post/linux-cgroup/</guid><description>cgroup和namespace类似，但是namespace会隔离不同进程组之间的资源，而cgroup是为了对进程组的资源进行限制和监控。 组</description></item><item><title>linux nf_conntrack</title><link>/post/linux-nf_conntrack/</link><pubDate>Tue, 13 Apr 2021 15:34:10 +0000</pubDate><guid>/post/linux-nf_conntrack/</guid><description>nf_conntrack是一个内核模块，其用于跟踪一个连接的状态。 为什么需要跟踪连接的状态？ nf_conntrack允许内核”审查”通过此处</description></item><item><title>Linux Route Flags and Types</title><link>/post/linux-route-flags-and-types/</link><pubDate>Sat, 03 Apr 2021 18:51:31 +0000</pubDate><guid>/post/linux-route-flags-and-types/</guid><description>Route Flags U（up）：此路由处于活动（up）中 G（Gateway）：指向网关 H（Host）：指向一个主机 R（Reinstate）：由动态路由重新初</description></item><item><title>STP/RSTP</title><link>/post/stp/</link><pubDate>Mon, 15 Mar 2021 14:02:47 +0000</pubDate><guid>/post/stp/</guid><description>STP/RSTP ​ 以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路，但是这也带来了网络环路的问题。网络环路会引发广播风暴和MAC地址表</description></item><item><title>RIB and FIB</title><link>/post/what-is-the-rib-and-fib/</link><pubDate>Thu, 04 Mar 2021 13:53:11 +0000</pubDate><guid>/post/what-is-the-rib-and-fib/</guid><description>RIB RIB（ Routing Information Base）是由节点上的各种路由过程建立的，其维护每种协议 ( 包含来自路由协议，如OSPF、is-is、BGP、静态条目 ) 的网络拓</description></item><item><title>iptables 四表五链</title><link>/post/iptables-%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE/</link><pubDate>Sat, 20 Feb 2021 00:37:21 +0000</pubDate><guid>/post/iptables-%E5%9B%9B%E8%A1%A8%E4%BA%94%E9%93%BE/</guid><description>前言 iptables只是一个工具，实际上内部核心是基于Netfilter 框架去实现其功能的一个命令行工具。 四表和五链 四表 首先表这概念主要是把</description></item><item><title>Disjoint_set</title><link>/post/disjoint-set/</link><pubDate>Tue, 02 Feb 2021 23:56:57 +0000</pubDate><guid>/post/disjoint-set/</guid><description>template type unionFind struct { parent, rank []int } func newunionFind(n int) *unionFind { parent := make([]int, n) rank := make([]int, n) for i := range parent { parent[i] = i rank[i] = 1 } return &amp;amp;unionFind{parent, rank} } func (uf *unionFind) find(x int) int { if uf.parent[x] != x { uf.parent[x] = uf.find(uf.parent[x]) } return uf.parent[x] } func (uf *unionFind) union(x, y int) bool { fx, fy := uf.find(x),</description></item><item><title>MPLS</title><link>/post/mpls/</link><pubDate>Thu, 28 Jan 2021 09:17:08 +0000</pubDate><guid>/post/mpls/</guid><description>基本概念 转发等价类 ​ MPLS作为一种分类转发技术，将具有相同转发处理方式的分组归为一类，称为FEC（Forwarding Equivalence Class，转发等</description></item><item><title>计算机网络</title><link>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</link><pubDate>Tue, 26 Jan 2021 00:27:00 +0000</pubDate><guid>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</guid><description>1.互联网组成 边缘部分：所有连接在互联网上的主机（主机指的是所有与网络直接相连的计算机）组成，用户可以直接使用，用来进行主机之间的通信和资源</description></item><item><title>C language - TCP/IP .h file and use Xdp</title><link>/post/c-language-tcpip-.h-file-and-use-xdp/</link><pubDate>Sat, 02 Jan 2021 16:17:01 +0000</pubDate><guid>/post/c-language-tcpip-.h-file-and-use-xdp/</guid><description>Commonly use .h network file IPv4 header netinet/ip.h：struct ip struct ip { #if BYTE_ORDER == LITTLE_ENDIAN u_char ip_hl:4, /* header length */ ip_v:4; /* version */ #endif #if BYTE_ORDER == BIG_ENDIAN u_char ip_v:4, /* version */ ip_hl:4; /* header length */ #endif u_char ip_tos; /* type of service */ short ip_len; /*</description></item><item><title>OSPF</title><link>/post/review-the-ospf/</link><pubDate>Sat, 02 Jan 2021 14:37:12 +0000</pubDate><guid>/post/review-the-ospf/</guid><description>Ospf作为链路状态路由协议，路由器之间交互的是LSA（链路状态通告），路由器将网络中泛洪的LSA搜集到自己的LSDB（链路状态数据库）中，</description></item><item><title>BGP</title><link>/post/review-the-bgp-protocol/</link><pubDate>Tue, 01 Dec 2020 02:13:41 +0000</pubDate><guid>/post/review-the-bgp-protocol/</guid><description>BGP对等体之间的交互原则 从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体。 从EBGP对等体获得的BGP路由，BGP设</description></item><item><title>nginx Compilation parameters</title><link>/post/%E8%AE%B0%E5%BD%95%E8%B4%B4nginx-compilation-parameters/</link><pubDate>Fri, 02 Oct 2020 16:44:52 +0000</pubDate><guid>/post/%E8%AE%B0%E5%BD%95%E8%B4%B4nginx-compilation-parameters/</guid><description>记录一下一些常见的nginx Compilation parameters。 基础配置 --prefix=_path_ 设置nginx安装目录路径 --sbin-path=_path_ 设置nginx可执行程序文件目录路径 --modules-path=_path_ 设置ngin</description></item><item><title>Go的几种编译模式</title><link>/post/go-compile-mode/</link><pubDate>Fri, 28 Aug 2020 22:21:23 +0000</pubDate><guid>/post/go-compile-mode/</guid><description>Go与C家族的互调，Go的几种编译模式。 一个程序编译成可执行程需要经过哪些 会经过4个步骤： 预编译：又称为预处理，是做些代码文本的替换工作。是</description></item><item><title>当TCP出现了大量的短链接时......</title><link>/post/%E5%BD%93tcp%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%97%B6/</link><pubDate>Mon, 24 Aug 2020 16:36:06 +0000</pubDate><guid>/post/%E5%BD%93tcp%E5%87%BA%E7%8E%B0%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84%E7%9F%AD%E9%93%BE%E6%8E%A5%E6%97%B6/</guid><description>问题 在一段时间里，有大量的短链接请求服务器，服务器会发生什么情况？ time_wait状态与可能导致情况 当TCP进入了四次挥手阶段，当主动请求</description></item><item><title>Go interface的interfacetype与_type</title><link>/post/%E5%85%B3%E4%BA%8Ego-interface%E7%9A%84interfacetype%E4%B8%8E-type/</link><pubDate>Thu, 06 Aug 2020 00:37:35 +0000</pubDate><guid>/post/%E5%85%B3%E4%BA%8Ego-interface%E7%9A%84interfacetype%E4%B8%8E-type/</guid><description>题目一 ........ type T interface{} type X string type Y = string func main() { var t T = &amp;#34;abc&amp;#34; var x X = &amp;#34;abc&amp;#34; var y Y = &amp;#34;abc&amp;#34; fmt.Println(t == x) fmt.Println(t == string(x)) fmt.Println(t == y) fmt.Println(t == string(y)) } // 输出false true true true interface的内部结构</description></item><item><title>Thread-Caching Malloc</title><link>/post/%E8%81%8A%E8%81%8Athread-caching-malloc/</link><pubDate>Sun, 02 Aug 2020 11:40:59 +0000</pubDate><guid>/post/%E8%81%8A%E8%81%8Athread-caching-malloc/</guid><description>前言 关于TCMalloc的相关资料和讲解，网上有很多关于其细节文章，在这就不一一阐述。主要目的是大体的结合官方文档和图片来阐述，但是具体细节</description></item><item><title>go 内存对齐</title><link>/post/data-structure-alignment/</link><pubDate>Sat, 18 Jul 2020 03:16:28 +0000</pubDate><guid>/post/data-structure-alignment/</guid><description>问题 在下面2个结构体所占的字节数又为多少？ type A struct{ a int8 d int16 c int32 b int64 } type B struct{ a int8 c int32 b int64 d int16 } 答案 答案显而易见，如果仔细观察就会发现A、B两个结</description></item><item><title>Go Race Detector</title><link>/post/%E5%85%B3%E4%BA%8Ego-race-detector/</link><pubDate>Thu, 16 Jul 2020 12:30:51 +0000</pubDate><guid>/post/%E5%85%B3%E4%BA%8Ego-race-detector/</guid><description>碰巧在看Go question的PDF时，意外发现在其上面所推荐的博客上看到一篇关于map 并发崩溃一例 的文章，他所使用的检查bug方法引起了我</description></item><item><title>wordpress backup</title><link>/post/%E5%85%B3%E4%BA%8Ewordpress-backup%E9%97%AE%E9%A2%98/</link><pubDate>Sun, 05 Jul 2020 00:58:49 +0000</pubDate><guid>/post/%E5%85%B3%E4%BA%8Ewordpress-backup%E9%97%AE%E9%A2%98/</guid><description>需求 对于个人而言，关于wordpress站点的备份，主要还是使用的内置的wordpress-importer来对站点里的内容进行备份，它会把</description></item><item><title>nginx epoll</title><link>/post/%E5%AF%B9epoll%E7%9A%84%E7%90%86%E8%A7%A3/</link><pubDate>Wed, 01 Jul 2020 01:52:28 +0000</pubDate><guid>/post/%E5%AF%B9epoll%E7%9A%84%E7%90%86%E8%A7%A3/</guid><description>前言 最近在调试个人博客时，发现服务器上的nginx居然没有配置epoll事件驱动，在之前学习Go的net包时，也接触过底层源码，也了解过其底</description></item><item><title>Copy-on-write</title><link>/post/%E6%B5%85%E8%B0%88copy-on-write/</link><pubDate>Sun, 28 Jun 2020 12:22:46 +0000</pubDate><guid>/post/%E6%B5%85%E8%B0%88copy-on-write/</guid><description>最近在看到了一种Copy-on-write(写时复制，COW)的技术，因此在这做一下记录 概念 根据Wikipedia和StackOverflo</description></item><item><title>Explicit Congestion Notification (ECN) in IP</title><link>/post/explicit-congestion-notification-ecn-in-ip/</link><pubDate>Thu, 18 Jun 2020 21:08:13 +0000</pubDate><guid>/post/explicit-congestion-notification-ecn-in-ip/</guid><description>TCP/IP的标记位 IP的ECN(显式拥塞通知) ECN使用IP首部的Tos字段最后2位(也称最低有效位)，根据RFC 3168 ，可以得知这2位分别成</description></item><item><title>go sync.Mutex</title><link>/post/go-sync.mutex/</link><pubDate>Wed, 17 Jun 2020 21:58:43 +0000</pubDate><guid>/post/go-sync.mutex/</guid><description>Mutex mutex有2种操作模式：正常和饥饿。在正常模式下，等待者按FIFO顺序排队，但唤醒的等待者不能马上获取锁，它还要和刚到达的gorouti</description></item><item><title>go map</title><link>/post/map-in-go/</link><pubDate>Tue, 16 Jun 2020 10:08:19 +0000</pubDate><guid>/post/map-in-go/</guid><description>哈希表 ​ 散列表，又叫哈希表（Hash Table），是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。也就是说，把关键字映射到一</description></item><item><title>最长上升子序列</title><link>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</link><pubDate>Mon, 15 Jun 2020 16:58:15 +0000</pubDate><guid>/post/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid><description>理解最长上升子序列的二分法（题目 ） 首先我们要维护数组d[i]来记录当前符合上升子序列的所有下标，len表示上升子序列的长度，那么情况下len</description></item><item><title>go channel中的自旋锁</title><link>/post/go-channel%E4%B8%AD%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81/</link><pubDate>Mon, 15 Jun 2020 15:34:17 +0000</pubDate><guid>/post/go-channel%E4%B8%AD%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81/</guid><description>首先了解几个参数 const ( active_spin = 4 //主动自旋 active_spin_cnt = 30 passive_spin = 1 //被动自旋 ) 关于active_spin_cnt目前没有找到相关解释，后面找到会补上。 hcan.lock 关</description></item><item><title>Go Goroutine的状态</title><link>/post/goroutine%E7%9A%84%E7%8A%B6%E6%80%81/</link><pubDate>Sat, 13 Jun 2020 21:32:03 +0000</pubDate><guid>/post/goroutine%E7%9A%84%E7%8A%B6%E6%80%81/</guid><description>Goroutine status，一个Goroutine从生到死，一共有8种状态，2个GC状态。 Gidle 表示该goroutine已经被分配，但是尚未初始化。_Gid</description></item><item><title>Channel in Go</title><link>/post/go-channel-/</link><pubDate>Sat, 13 Jun 2020 12:08:50 +0000</pubDate><guid>/post/go-channel-/</guid><description>chan结构 type hchan struct { qcount uint // buffer的总数据量 dataqsiz uint // circular(圆) queue的大小（可以理解为环形链表） buf unsafe.Pointer // 一个指向buffer</description></item><item><title>go sync.Map</title><link>/post/go-sync.map/</link><pubDate>Wed, 10 Jun 2020 11:32:23 +0000</pubDate><guid>/post/go-sync.map/</guid><description>sync.Map的主要结构 Map type Map struct { mu Mutex //锁 read atomic.Value // readOnly 只读数据 dirty map[interface{}]*entry //存储数据，允许读写，但要用锁 //未命中次数，主要记录read读取不到数</description></item><item><title>Context in Go</title><link>/post/go-context/</link><pubDate>Tue, 09 Jun 2020 12:15:38 +0000</pubDate><guid>/post/go-context/</guid><description>![](/images/Context in Go/20200609041455723.png) Context Interface type Context interface { //超过时间，该context便死亡 Deadline() (deadline time.Time, ok bool) //当context结束时，返回一个channel Done() &amp;lt;-chan struct{} //context错</description></item><item><title>链表反转</title><link>/post/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/</link><pubDate>Fri, 05 Jun 2020 14:11:28 +0000</pubDate><guid>/post/%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8F%8D%E8%BD%AC/</guid><description>链表的反转的类型，就我目前做题的经历和情况来看，目前我一共遇到2种类型的链表反转，第一类是最简单的把整条链表反转，第二类就是把链表中的某一段</description></item><item><title>Go中的defer</title><link>/post/go%E4%B8%AD%E7%9A%84defer/</link><pubDate>Thu, 04 Jun 2020 01:42:26 +0000</pubDate><guid>/post/go%E4%B8%AD%E7%9A%84defer/</guid><description>例子1： func increaseA() int { var i int defer func() { i++ }() return i //注意这是个匿名返回值 } func increaseB() (r int) { defer func() { r++ }() return r } 例子2： func f1() (r int) { defer func() { r++ }() return 0 } func f2() (r int) { t := 5 defer</description></item><item><title>Go goroutine Stack</title><link>/post/goroutine-stack/</link><pubDate>Mon, 01 Jun 2020 22:56:00 +0000</pubDate><guid>/post/goroutine-stack/</guid><description>前言 goroutine需要自己的栈才能够运行。假如每个goroutine分配的栈固定，那么这个栈太小则会导致溢出，太大又会浪费空间，因此如果</description></item><item><title>关于我</title><link>/about.html</link><pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate><guid>/about.html</guid><description>Hugo是用Go编写的一个开放源代码静态站点生成器，可在Apache许可证2.0 下使用。 Hugo支持TOML, YAML和JSON数据文件类型</description></item></channel></rss>