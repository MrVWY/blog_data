<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Canon Blog</title><link>/categories/go/</link><description>Recent content in Go on Canon Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 18 Apr 2023 17:55:01 +0000</lastBuildDate><atom:link href="/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>go sync/atomic</title><link>/post/sync-atomic/</link><pubDate>Tue, 18 Apr 2023 17:55:01 +0000</pubDate><guid>/post/sync-atomic/</guid><description>定义 原子操作是一种可以在不加锁的情况下，对内存数据进行读写的操作, 使用sync/atomic提供的原子操作可以确保在任意时刻只有一个goro</description></item><item><title>go runtime.SetFinalizer 用法</title><link>/post/runtime-setfinalizer/</link><pubDate>Sat, 18 Feb 2023 10:34:47 +0000</pubDate><guid>/post/runtime-setfinalizer/</guid><description>runtime.SetFinalizer可以在内存中对象被回收前(gc)，指定一些操作。 用法 document : https://pkg.go.dev/runtime#SetFinalizer //SetFinalizer sets the finalizer associated with obj to the provided finalizer function. When the garbage collector finds an unreachable block with</description></item><item><title>go http.transport</title><link>/post/go-http-transport/</link><pubDate>Sat, 10 Dec 2022 15:00:42 +0000</pubDate><guid>/post/go-http-transport/</guid><description>​ 理解一下golang标准库里面的net/http包中的client类型，但是其实client类型也是通过实现RoundTripper接口来</description></item><item><title>go slice</title><link>/post/go-slice/</link><pubDate>Wed, 06 Jul 2022 21:11:34 +0000</pubDate><guid>/post/go-slice/</guid><description>1、切片结构 一个切片由3部分组成：指针、长度和容量。指针指向底层数组，长度代表slice当前的长度，容量代表底层数组的长度，同时切片的长度可</description></item><item><title>go 如何实现线程安全（并发安全）的 map</title><link>/post/go-%E5%B9%B6%E5%8F%91map/</link><pubDate>Fri, 27 May 2022 11:02:08 +0000</pubDate><guid>/post/go-%E5%B9%B6%E5%8F%91map/</guid><description>在网上查了查如何实现线程安全（并发安全）的 map，发现了几种方法。 sync.RWMutex 加读写锁 //例子 type RWMap struct { // 一个读写锁保护的线程安全的map sync.RWMutex // 读写锁保护</description></item><item><title>go map 存储方法</title><link>/post/go-map-save-and-use-func/</link><pubDate>Sat, 16 Apr 2022 11:51:57 +0000</pubDate><guid>/post/go-map-save-and-use-func/</guid><description>背景 最近在公司重构个系统的时候，由于某一个流程需要按需来自定义功能来进行处理，于是我想着用一个map来做一个映射关系，然后在这个流程中利用一</description></item><item><title>Go 基础知识点</title><link>/post/go-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</link><pubDate>Sun, 12 Sep 2021 15:49:10 +0000</pubDate><guid>/post/go-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</guid><description>记录一下golang的基础要点，以方便后续复习 GC 标记清除 ​ 标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式</description></item><item><title>Go的几种编译模式</title><link>/post/go-compile-mode/</link><pubDate>Fri, 28 Aug 2020 22:21:23 +0000</pubDate><guid>/post/go-compile-mode/</guid><description>Go与C家族的互调，Go的几种编译模式。 一个程序编译成可执行程需要经过哪些 会经过4个步骤： 预编译：又称为预处理，是做些代码文本的替换工作。是</description></item><item><title>Go interface的interfacetype与_type</title><link>/post/%E5%85%B3%E4%BA%8Ego-interface%E7%9A%84interfacetype%E4%B8%8E-type/</link><pubDate>Thu, 06 Aug 2020 00:37:35 +0000</pubDate><guid>/post/%E5%85%B3%E4%BA%8Ego-interface%E7%9A%84interfacetype%E4%B8%8E-type/</guid><description>题目一 ........ type T interface{} type X string type Y = string func main() { var t T = &amp;#34;abc&amp;#34; var x X = &amp;#34;abc&amp;#34; var y Y = &amp;#34;abc&amp;#34; fmt.Println(t == x) fmt.Println(t == string(x)) fmt.Println(t == y) fmt.Println(t == string(y)) } // 输出false true true true interface的内部结构</description></item><item><title>go 内存对齐</title><link>/post/data-structure-alignment/</link><pubDate>Sat, 18 Jul 2020 03:16:28 +0000</pubDate><guid>/post/data-structure-alignment/</guid><description>问题 在下面2个结构体所占的字节数又为多少？ type A struct{ a int8 d int16 c int32 b int64 } type B struct{ a int8 c int32 b int64 d int16 } 答案 答案显而易见，如果仔细观察就会发现A、B两个结</description></item><item><title>Go Race Detector</title><link>/post/%E5%85%B3%E4%BA%8Ego-race-detector/</link><pubDate>Thu, 16 Jul 2020 12:30:51 +0000</pubDate><guid>/post/%E5%85%B3%E4%BA%8Ego-race-detector/</guid><description>碰巧在看Go question的PDF时，意外发现在其上面所推荐的博客上看到一篇关于map 并发崩溃一例 的文章，他所使用的检查bug方法引起了我</description></item><item><title>go sync.Mutex</title><link>/post/go-sync.mutex/</link><pubDate>Wed, 17 Jun 2020 21:58:43 +0000</pubDate><guid>/post/go-sync.mutex/</guid><description>Mutex mutex有2种操作模式：正常和饥饿。在正常模式下，等待者按FIFO顺序排队，但唤醒的等待者不能马上获取锁，它还要和刚到达的gorouti</description></item><item><title>go map</title><link>/post/map-in-go/</link><pubDate>Tue, 16 Jun 2020 10:08:19 +0000</pubDate><guid>/post/map-in-go/</guid><description>哈希表 ​ 散列表，又叫哈希表（Hash Table），是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。也就是说，把关键字映射到一</description></item><item><title>go channel中的自旋锁</title><link>/post/go-channel%E4%B8%AD%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81/</link><pubDate>Mon, 15 Jun 2020 15:34:17 +0000</pubDate><guid>/post/go-channel%E4%B8%AD%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81/</guid><description>首先了解几个参数 const ( active_spin = 4 //主动自旋 active_spin_cnt = 30 passive_spin = 1 //被动自旋 ) 关于active_spin_cnt目前没有找到相关解释，后面找到会补上。 hcan.lock 关</description></item><item><title>Go Goroutine的状态</title><link>/post/goroutine%E7%9A%84%E7%8A%B6%E6%80%81/</link><pubDate>Sat, 13 Jun 2020 21:32:03 +0000</pubDate><guid>/post/goroutine%E7%9A%84%E7%8A%B6%E6%80%81/</guid><description>Goroutine status，一个Goroutine从生到死，一共有8种状态，2个GC状态。 Gidle 表示该goroutine已经被分配，但是尚未初始化。_Gid</description></item><item><title>Channel in Go</title><link>/post/go-channel-/</link><pubDate>Sat, 13 Jun 2020 12:08:50 +0000</pubDate><guid>/post/go-channel-/</guid><description>chan结构 type hchan struct { qcount uint // buffer的总数据量 dataqsiz uint // circular(圆) queue的大小（可以理解为环形链表） buf unsafe.Pointer // 一个指向buffer</description></item><item><title>go sync.Map</title><link>/post/go-sync.map/</link><pubDate>Wed, 10 Jun 2020 11:32:23 +0000</pubDate><guid>/post/go-sync.map/</guid><description>sync.Map的主要结构 Map type Map struct { mu Mutex //锁 read atomic.Value // readOnly 只读数据 dirty map[interface{}]*entry //存储数据，允许读写，但要用锁 //未命中次数，主要记录read读取不到数</description></item><item><title>Context in Go</title><link>/post/go-context/</link><pubDate>Tue, 09 Jun 2020 12:15:38 +0000</pubDate><guid>/post/go-context/</guid><description>![](/images/Context in Go/20200609041455723.png) Context Interface type Context interface { //超过时间，该context便死亡 Deadline() (deadline time.Time, ok bool) //当context结束时，返回一个channel Done() &amp;lt;-chan struct{} //context错</description></item><item><title>Go中的defer</title><link>/post/go%E4%B8%AD%E7%9A%84defer/</link><pubDate>Thu, 04 Jun 2020 01:42:26 +0000</pubDate><guid>/post/go%E4%B8%AD%E7%9A%84defer/</guid><description>例子1： func increaseA() int { var i int defer func() { i++ }() return i //注意这是个匿名返回值 } func increaseB() (r int) { defer func() { r++ }() return r } 例子2： func f1() (r int) { defer func() { r++ }() return 0 } func f2() (r int) { t := 5 defer</description></item><item><title>Go goroutine Stack</title><link>/post/goroutine-stack/</link><pubDate>Mon, 01 Jun 2020 22:56:00 +0000</pubDate><guid>/post/goroutine-stack/</guid><description>前言 goroutine需要自己的栈才能够运行。假如每个goroutine分配的栈固定，那么这个栈太小则会导致溢出，太大又会浪费空间，因此如果</description></item></channel></rss>