<!doctype html><html lang=zh-cn dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>Go goroutine Stack - Canon Blog</title><meta name=keywords content="博客,程序员,读书,笔记,技术,分享"><meta name=author content="Canon"><meta property="og:title" content="Go goroutine Stack"><meta property="og:site_name" content="Canon Blog"><meta property="og:image" content="/img/author.jpg"><meta name=title content="Go goroutine Stack - Canon Blog"><meta name=description content="欢迎来到Canon的博客"><link rel="shortcut icon" href=/img/favicon.ico><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>Canon Blog</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>记录学习资料!</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline" style=font-weight:700><a class=post-title-link href=/post/goroutine-stack/ itemprop=url>Go goroutine Stack</a></h1></header><div class=post-body itemprop=articleBody><h4 id=前言>前言</h4><p>goroutine需要自己的栈才能够运行。假如每个goroutine分配的栈固定，那么这个栈太小则会导致溢出，太大又会浪费空间，因此如果这样的gorouting有成千上万个，那么系统是无法容纳众多的goroutine的。 因此在当前Go版本中， goroutine就已经在使用连续栈的形式来为其分配内存空间，该形式可以让goroutine尽可能的把内存空间最大化利用同时，也能正常运行。</p><h4 id=goroutine-stack-的结构体定义>Goroutine Stack 的结构体定义</h4><p>首先我们来看一下在Go的源码中对 Goroutine Stack 的结构体定义：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> stack <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>   lo <span style=color:#0b0;font-weight:700>uintptr</span>  栈空间的低地址
</span></span><span style=display:flex><span>   hi <span style=color:#0b0;font-weight:700>uintptr</span>  栈空间的高地址
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>// uintptr is an integer type that is large enough to hold the bit pattern of
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>// any pointer.
</span></span></span></code></pre></div><p>每当我们起一个 goroutine 时，Go会给这个 goroutine 分配一个内存空间，其大小基于所使用的平台，在源码的定义如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// Number of orders that get caching. Order 0 is FixedStack
</span></span><span style=display:flex><span>// and each successive order is twice as large.
</span></span><span style=display:flex><span>// We want to cache 2KB, 4KB, 8KB, and 16KB stacks. Larger stacks
</span></span><span style=display:flex><span>// will be allocated directly.
</span></span><span style=display:flex><span>// Since FixedStack is different on different systems, we
</span></span><span style=display:flex><span>// must vary NumStackOrders to keep the same maximum cached size.
</span></span><span style=display:flex><span>//   OS                FixedStack  NumStackOrders
</span></span><span style=display:flex><span>//   -----------------+------------+---------------
</span></span><span style=display:flex><span>//   linux/darwin/bsd  2KB         4
</span></span><span style=display:flex><span>//   windows/32        4KB         3
</span></span><span style=display:flex><span>//   windows/64        8KB         2
</span></span><span style=display:flex><span>//   plan9             4KB         3
</span></span></code></pre></div><h4 id=栈的初始化>栈的初始化</h4><p>首先是对栈的初始化：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>stackinit</span>() {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> _StackCacheSize<span style=color:#666>&amp;</span>_PageMask <span style=color:#666>!=</span> <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#00a000>throw</span>(<span style=color:#b44>&#34;cache size must be a multiple of page size&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>            <span style=color:#080;font-style:italic>//从栈池中取出一个栈来init()相当对mSpanList初始化
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> stackpool {
</span></span><span style=display:flex><span>        stackpool[i].<span style=color:#00a000>init</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> i <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> stackLarge.free {
</span></span><span style=display:flex><span>        stackLarge.free[i].<span style=color:#00a000>init</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其中对于stackpool栈池，它的定义是一个 <code>[_NumStackOrders]mSpanList</code> ,而 <code>mSpanList</code> 涉及到Go的内存管理，在这里先不展开。而<code>stackLarge（// Global pool of large stack spans.）</code>个人理解是是最大栈空间全局池。spans可以理解为一块内存。</p><h4 id=栈的增大>栈的增大</h4><p>接下来我们看看当 Goroutine 在运行时栈空间需要增加是如何操作的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>newstack</span>() {
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//获取当前的goroutine
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    thisg <span style=color:#666>:=</span> <span style=color:#00a000>getg</span>() 
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// TODO: double check all gp. shouldn&#39;t be getg().
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#666>.........</span>..中间代码省略<span style=color:#666>...............</span>.
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// Allocate a bigger segment and move the stack.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    oldsize <span style=color:#666>:=</span> gp.stack.hi <span style=color:#666>-</span> gp.stack.lo
</span></span><span style=display:flex><span>    newsize <span style=color:#666>:=</span> oldsize <span style=color:#666>*</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> newsize &gt; maxstacksize {
</span></span><span style=display:flex><span>        <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;runtime: goroutine stack exceeds &#34;</span>, maxstacksize, <span style=color:#b44>&#34;-byte limit\\n&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#00a000>throw</span>(<span style=color:#b44>&#34;stack overflow&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//修改该协程的状态 由_Grunning 变成_Gcopystack
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>casgstatus</span>(gp, _Grunning, _Gcopystack)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// The concurrent GC will not scan the stack while we are doing the copy since   将当前栈的数据复制到新的栈中
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// the gp is in a Gcopystack status.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>copystack</span>(gp, newsize, <span style=color:#a2f;font-weight:700>true</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> stackDebug <span style=color:#666>&gt;=</span> <span style=color:#666>1</span> {
</span></span><span style=display:flex><span>    	<span style=color:#a2f>print</span>(<span style=color:#b44>&#34;stack grow done\\n&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//修改该协程的状态 由_Gcopystack变成 _Grunning
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#00a000>casgstatus</span>(gp, _Gcopystack, _Grunning)
</span></span><span style=display:flex><span>    <span style=color:#00a000>gogo</span>(<span style=color:#666>&amp;</span>gp.sched)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从源码来看，一个 Goroutine 栈空间增大的过程为，先获取当前的goroutine，更新syscallsp和syscallpc，应该是防止在增大栈空间时系统又回调了这个 Goroutine ，然后中间的代码（看的我一脸懵）和注解，个人的见解为，在 Goroutine 增大栈的过程中，会令 Goroutine 的状态发生改变，这时候GC的什么写屏障和 Goroutine 抢占的问题就会出现，因此这不详细说明。接着就计算新栈的空间，其等于旧栈空间的一倍（<code>newsize := oldsize * 2</code>）然后把该协程g的状态由 _Grunning 变 _Gcopystack，复制数据到新栈，把 该协程g 恢复原状，进而完成栈增大操作。</p><h4 id=栈的复制>栈的复制</h4><p>接着上述我们看看copystack()是如何操作的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>copystack</span>(gp <span style=color:#666>*</span>g, newsize <span style=color:#0b0;font-weight:700>uintptr</span>, sync <span style=color:#0b0;font-weight:700>bool</span>) {
</span></span><span style=display:flex><span>    <span style=color:#666>......</span>.
</span></span><span style=display:flex><span>    old <span style=color:#666>:=</span> gp.stack
</span></span><span style=display:flex><span>    <span style=color:#666>......</span>.
</span></span><span style=display:flex><span>    used <span style=color:#666>:=</span> old.hi <span style=color:#666>-</span> gp.sched.sp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 分配新堆栈
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    new <span style=color:#666>:=</span> <span style=color:#00a000>stackalloc</span>(<span style=color:#a2f>uint32</span>(newsize))
</span></span><span style=display:flex><span>    <span style=color:#666>.........</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// Compute adjustment. 这一步应该是调整旧栈指针
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>var</span> adjinfo adjustinfo
</span></span><span style=display:flex><span>    adjinfo.old = old
</span></span><span style=display:flex><span>    adjinfo.delta = new.hi <span style=color:#666>-</span> old.hi
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>.........</span>.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 将旧栈复制到新位置
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>memmove</span>(unsafe.<span style=color:#00a000>Pointer</span>(new.hi<span style=color:#666>-</span>ncopy), unsafe.<span style=color:#00a000>Pointer</span>(old.hi<span style=color:#666>-</span>ncopy), ncopy)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// Adjust remaining structures that have pointers into stacks.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// We have to do most of these before we traceback the new
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// stack because gentraceback uses them.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>adjustctxt</span>(gp, <span style=color:#666>&amp;</span>adjinfo)
</span></span><span style=display:flex><span>    <span style=color:#00a000>adjustdefers</span>(gp, <span style=color:#666>&amp;</span>adjinfo)
</span></span><span style=display:flex><span>    <span style=color:#00a000>adjustpanics</span>(gp, <span style=color:#666>&amp;</span>adjinfo)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> adjinfo.sghi <span style=color:#666>!=</span> <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>    adjinfo.sghi <span style=color:#666>+=</span> adjinfo.delta
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// Swap out old stack for new one
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    gp.stack = new
</span></span><span style=display:flex><span>    gp.stackguard0 = new.lo <span style=color:#666>+</span> _StackGuard <span style=color:#080;font-style:italic>// NOTE: might clobber a preempt request
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    gp.sched.sp = new.hi <span style=color:#666>-</span> used
</span></span><span style=display:flex><span>    gp.stktopsp <span style=color:#666>+=</span> adjinfo.delta
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 调整新栈中的指针
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>gentraceback</span>(^<span style=color:#a2f>uintptr</span>(<span style=color:#666>0</span>), ^<span style=color:#a2f>uintptr</span>(<span style=color:#666>0</span>), <span style=color:#666>0</span>, gp, <span style=color:#666>0</span>, <span style=color:#a2f;font-weight:700>nil</span>, <span style=color:#666>0x7fffffff</span>, adjustframe, <span style=color:#00a000>noescape</span>(unsafe.<span style=color:#00a000>Pointer</span>(<span style=color:#666>&amp;</span>adjinfo)), <span style=color:#666>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// 释放旧栈
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> stackPoisonCopy <span style=color:#666>!=</span> <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#00a000>fillstack</span>(old, <span style=color:#666>0xfc</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#00a000>stackfree</span>(old)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从源码来看，一个 Goroutine 栈的复制的过程大致为，先计算调整旧栈的指针，然后再把旧栈复制到新栈中，最后调整新栈的指针(<strong>gentraceback</strong>)和释放旧栈。注意复制栈的过程需要的条件为：当前栈的状态一定是 _Gcopystack 。</p><h4 id=栈的缩小>栈的缩小</h4><p>既然有 Goroutine的增栈，那么必然有 Goroutine 的缩栈，下面我们来看一下缩栈的操作。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#080;font-style:italic>// Maybe shrink the stack being used by gp.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>// Called at garbage collection time.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>// gp must be stopped, but the world need not be.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic>//由上面的注释可以知道,缩栈是在垃圾回收时间做的
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>shrinkstack</span>(gp <span style=color:#666>*</span>g) {
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//获取当前g的状态
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    gstatus <span style=color:#666>:=</span> <span style=color:#00a000>readgstatus</span>(gp)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> gp.stack.lo <span style=color:#666>==</span> <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>    	<span style=color:#00a000>throw</span>(<span style=color:#b44>&#34;missing stack in shrinkstack&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> gstatus<span style=color:#666>&amp;</span>_Gscan <span style=color:#666>==</span> <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>    	<span style=color:#00a000>throw</span>(<span style=color:#b44>&#34;bad status in shrinkstack&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>............</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//计算新栈的newsize,从这里可以看出Go缩栈是缩小到原来的一半
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span>    oldsize <span style=color:#666>:=</span> gp.stack.hi <span style=color:#666>-</span> gp.stack.lo
</span></span><span style=display:flex><span>    newsize <span style=color:#666>:=</span> oldsize <span style=color:#666>/</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// Don&#39;t shrink the allocation below the minimum-sized stack
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// allocation.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#a2f;font-weight:700>if</span> newsize &lt; _FixedStack {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// Compute how much of the stack is currently in use and only
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// shrink the stack if gp is using less than a quarter of its
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// current stack. The currently used stack includes everything
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// down to the SP plus the stack guard space that ensures
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// there&#39;s room for nosplit functions.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//当已使用的栈占不到总栈的1/4 进行缩容
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span>    avail <span style=color:#666>:=</span> gp.stack.hi <span style=color:#666>-</span> gp.stack.lo
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> used <span style=color:#666>:=</span> gp.stack.hi <span style=color:#666>-</span> gp.sched.sp <span style=color:#666>+</span> _StackLimit; used <span style=color:#666>&gt;=</span> avail<span style=color:#666>/</span><span style=color:#666>4</span> {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>// We can&#39;t copy the stack if we&#39;re in a syscall.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#080;font-style:italic>// The syscall might have pointers into the stack.
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//判断当前栈是否在被系统调用,如果正在被调用那么syscall可以有指针在当前栈里面
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> gp.syscallsp <span style=color:#666>!=</span> <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> sys.GoosWindows <span style=color:#666>!=</span> <span style=color:#666>0</span> <span style=color:#666>&amp;&amp;</span> gp.m <span style=color:#666>!=</span> <span style=color:#a2f;font-weight:700>nil</span> <span style=color:#666>&amp;&amp;</span> gp.m.libcallsp <span style=color:#666>!=</span> <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> stackDebug &gt; <span style=color:#666>0</span> {
</span></span><span style=display:flex><span>    <span style=color:#a2f>print</span>(<span style=color:#b44>&#34;shrinking stack &#34;</span>, oldsize, <span style=color:#b44>&#34;-&gt;&#34;</span>, newsize, <span style=color:#b44>&#34;\\n&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic>//最后把数据复制到新栈中
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>    <span style=color:#00a000>copystack</span>(gp, newsize, <span style=color:#a2f;font-weight:700>false</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从 Goroutine 缩栈的源码来看，缩栈的大致过程为，先获取当前goroutine的状态进来判断，然后计算newsize，另外如果gp使用少于其四分之一的空间，则缩小堆栈 。检查当前g是否正在被系统调用， 如果当前g正在被系统调用就直接return回去然后等待系统调用结束，最后把数据复制到新栈中。</p><h4 id=goroutine-stack-frame>Goroutine Stack Frame</h4><p>建议先了解 Stack Frame</p><h5 id=fpsppc-lr>FP，SP，PC ，LR</h5><p>PC： 程序计数器 SP： 保存栈顶的地址 FP ： 保存栈底的地址 LR ： 连接寄存器的程序计数器</p><h5 id=stack-frame-layout>Stack frame layout</h5><p>从Go的源码可以得知Stack frame 的设计如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// (x86)
</span></span><span style=display:flex><span>// +------------------+
</span></span><span style=display:flex><span>//  args from caller   //调用者的args
</span></span><span style=display:flex><span>// +------------------+ &lt;- frame-&gt;argp
</span></span><span style=display:flex><span>//   return address  
</span></span><span style=display:flex><span>// +------------------+
</span></span><span style=display:flex><span>//   caller&#39;s BP (\*)  (\*) if framepointer\_enabled &amp;&amp; varp &lt; sp
</span></span><span style=display:flex><span>// +------------------+ &lt;- frame-&gt;varp
</span></span><span style=display:flex><span>//      locals       
</span></span><span style=display:flex><span>// +------------------+
</span></span><span style=display:flex><span>//   args to callee    //被调用者的args
</span></span><span style=display:flex><span>// +------------------+ &lt;- frame-&gt;sp
</span></span><span style=display:flex><span>//
</span></span><span style=display:flex><span>// (arm)
</span></span><span style=display:flex><span>// +------------------+
</span></span><span style=display:flex><span>//  args from caller 
</span></span><span style=display:flex><span>// +------------------+ &lt;- frame-&gt;argp
</span></span><span style=display:flex><span>//  caller&#39;s retaddr 
</span></span><span style=display:flex><span>// +------------------+ &lt;- frame-&gt;varp
</span></span><span style=display:flex><span>//      locals       
</span></span><span style=display:flex><span>// +------------------+
</span></span><span style=display:flex><span>//   args to callee  
</span></span><span style=display:flex><span>// +------------------+
</span></span><span style=display:flex><span>//   return address  
</span></span><span style=display:flex><span>// +------------------+ &lt;- frame-&gt;sp
</span></span></code></pre></div><p>同时还要关注一下这个 结构体 stack traces（栈的跟踪）</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> stkframe <span style=color:#a2f;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>   fn       funcInfo   <span style=color:#080;font-style:italic>// function being run
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   pc       <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// program counter within fn
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   continpc <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// program counter where execution can continue, or 0 if not
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   lr       <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// program counter at caller aka link register
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   sp       <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// stack pointer at pc
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   fp       <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// stack pointer at caller aka frame pointer
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   varp     <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// top of local variables
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   argp     <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// pointer to function arguments
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   arglen   <span style=color:#0b0;font-weight:700>uintptr</span>    <span style=color:#080;font-style:italic>// number of bytes at argp
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>   argmap   <span>\</span><span style=color:#666>*</span>bitvector <span style=color:#080;font-style:italic>// force use of this argmap
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>}
</span></span></code></pre></div><h4 id=关于调整新旧栈的指针>关于调整新旧栈的指针</h4><p>从函数gentraceback()开始，由于 gentraceback() 代码量过于庞大，这里我们只关注 PC，SP，FP，LR 和与stkframe 相关 的代码部分。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>......
</span></span><span style=display:flex><span>var frame stkframe
</span></span><span style=display:flex><span>frame.pc = pc0
</span></span><span style=display:flex><span>frame.sp = sp0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>//findfunc-&gt;findmoduledatap ,他返回时一个moduledata对象，其记录有关可执行文件布局的信息
</span></span><span style=display:flex><span>f := findfunc(frame.pc)
</span></span><span style=display:flex><span>......
</span></span><span style=display:flex><span>frame.fn = f
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>for n &lt; max {
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>        f = frame.fn
</span></span><span style=display:flex><span>        if f.pcsp == 0 {
</span></span><span style=display:flex><span>            // No frame information, must be external function, like race support.
</span></span><span style=display:flex><span>            // See golang.org/issue/13568.
</span></span><span style=display:flex><span>            break
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>        if frame.fp == 0 {
</span></span><span style=display:flex><span>            sp := frame.sp
</span></span><span style=display:flex><span>            ......
</span></span><span style=display:flex><span>            //计算FP
</span></span><span style=display:flex><span>            frame.fp = sp + uintptr(funcspdelta(f, frame.pc, &amp;cache))
</span></span><span style=display:flex><span>            if !usesLR {
</span></span><span style=display:flex><span>  // On x86, call instruction pushes return PC before entering new function.
</span></span><span style=display:flex><span>                frame.fp += sys.RegSize
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        var flr funcInfo
</span></span><span style=display:flex><span>        if topofstack(f, gp.m != nil &amp;&amp; gp == gp.m.g0) {
</span></span><span style=display:flex><span>            ......
</span></span><span style=display:flex><span>        } else if usesLR &amp;&amp; f.funcID == funcID\_jmpdefer {
</span></span><span style=display:flex><span>            ......
</span></span><span style=display:flex><span>        } else {
</span></span><span style=display:flex><span>            var lrPtr uintptr
</span></span><span style=display:flex><span>            if usesLR {
</span></span><span style=display:flex><span>                ......
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                if frame.lr == 0 {
</span></span><span style=display:flex><span>                    lrPtr = frame.fp - sys.RegSize
</span></span><span style=display:flex><span>                    frame.lr = uintptr(\*(\*sys.Uintreg)(unsafe.Pointer(lrPtr)))
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            flr = findfunc(frame.lr)
</span></span><span style=display:flex><span>            ......
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //top of local variables
</span></span><span style=display:flex><span>    frame.varp = frame.fp 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if !usesLR {
</span></span><span style=display:flex><span>        // On x86, call instruction pushes return PC before entering new function.
</span></span><span style=display:flex><span>        frame.varp -= sys.RegSize
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ......
</span></span><span style=display:flex><span>    if framepointer\_enabled &amp;&amp; GOARCH == &#34;amd64&#34; &amp;&amp; frame.varp &gt; frame.sp {
</span></span><span style=display:flex><span>        frame.varp -= sys.RegSize
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ......
</span></span><span style=display:flex><span>    if callback != nil  printing {
</span></span><span style=display:flex><span>       frame.argp = frame.fp + sys.MinFrameSize
</span></span><span style=display:flex><span>        ......
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ......
</span></span><span style=display:flex><span>    // Unwind to next frame. 退至下一帧
</span></span><span style=display:flex><span>    frame.fn = flr
</span></span><span style=display:flex><span>    frame.pc = frame.lr
</span></span><span style=display:flex><span>    frame.lr = 0
</span></span><span style=display:flex><span>    frame.sp = frame.fp
</span></span><span style=display:flex><span>    frame.fp = 0
</span></span><span style=display:flex><span>    frame.argmap = nil
</span></span><span style=display:flex><span>    ......
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>......
</span></span></code></pre></div><p>到这 goroutine Stack 也说的差不多了</p><h4 id=总结>总结</h4><p>从 Goroutine 栈的实现方式上可以知道，不管栈扩大还是缩小，都会重新申请一块新栈（新的一块内存），然后把旧栈的数据复制到新栈，相当于完整替换了Goroutine使用的物理内存，再借助指针重新指向新栈，便完成了栈大小改变过程。</p></div><footer class=post-footer></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.jpeg alt=Canon><p class=site-author-name itemprop=name>Canon</p><p class="site-description motion-element" itemprop=description>慢慢走, 慢慢来!</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>48</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/MrVWY target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://github.com/MrVWY/Learn-Note target=_blank title=笔记><i class="fa fa-fw fa-globe"></i>
笔记</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/go>Go
<sup>20</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2>路由交换
<sup>6</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/leetcode>Leetcode
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/linux>Linux
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/tcp/ip>Tcp IP
<sup>3</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/c>C
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/js>Js
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/network>Network
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/nginx>Nginx
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/tcp/iplinux>Tcp iplinux
<sup>1</sup></a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li></li></ul></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2021 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>Canon Blog</span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href style=font-weight:700 target=_blank></a></span>
<span class=separator-line>/</span>
<span class=license-num><a href target=_blank></a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=/js/search.js></script>
<script type=text/javascript src=/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var e,t,n,s,o=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":o}).show(),t=parseInt($("#sidebar").css("margin-top")),n=parseInt($(".sidebar-inner").css("height")),e=t+n,s=$(".content-wrap").height(),s<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>