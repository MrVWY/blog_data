<!doctype html><html lang=zh-cn dir=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=content-security-policy content="upgrade-insecure-requests"><title>计算机网络 - Canon Blog</title><meta name=keywords content="博客,程序员,读书,笔记,技术,分享"><meta name=author content="Canon"><meta property="og:title" content="计算机网络"><meta property="og:site_name" content="Canon Blog"><meta property="og:image" content="/img/author.jpg"><meta name=title content="计算机网络 - Canon Blog"><meta name=description content="欢迎来到Canon的博客"><link rel="shortcut icon" href=/img/favicon.ico><link href=//unpkg.com/font-awesome@4.7.0/css/font-awesome.min.css rel=stylesheet type=text/css><link href=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.css rel=stylesheet><link href=/css/main.css rel=stylesheet type=text/css><link href=/css/syntax.css rel=stylesheet type=text/css></head><body itemscope itemtype=http://schema.org/WebPage lang=zh-Hans><div class="container one-collumn sidebar-position-left page-home"><div class=headband></div><header id=header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle role=button style=opacity:1;top:0><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><div class=custom-logo-site-title><a href=/ class=brand rel=start><span class=logo-line-before><i></i></span>
<span class=site-title>Canon Blog</span>
<span class=logo-line-after><i></i></span></a></div><p class=site-subtitle>记录学习资料!</p></div><div class=site-nav-right><div class="toggle popup-trigger" style=opacity:1;top:0><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul id=menu class=menu><li class=menu-item><a href=/ rel=section><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-active"><a href=/post rel=section><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href=javascript:; class=popup-trigger><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon><i class="fa fa-search"></i></span>
<span class=popup-btn-close><i class="fa fa-times-circle"></i></span><div class=local-search-input-wrapper><input autocomplete=off placeholder=搜索关键字... spellcheck=false type=text id=local-search-input autocapitalize=none autocorrect=off></div></div><div id=local-search-result></div></div></div></nav></div></header><main id=main class=main><div class=main-inner><div class=content-wrap><div id=content class=content><section id=posts class=posts-expand><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><header class=post-header><h1 class=post-title itemprop="name headline" style=font-weight:700><a class=post-title-link href=/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/ itemprop=url>计算机网络</a></h1></header><div class=post-body itemprop=articleBody><h2 id=1互联网组成>1.互联网组成</h2><ul><li><p>边缘部分：所有连接在互联网上的主机（主机指的是所有与网络直接相连的计算机）组成，用户可以直接使用，用来进行主机之间的通信和资源共享。</p><p>通信的方式主要有两种：</p><ul><li>客户-服务器方式：即C /S方式。客户端发送服务的请求，服务器是服务的提供方。</li><li>P2P：对等连接方式。两台通信的主机之间不区分哪个是客户，哪个是服务端，只要两台主机都运行了对等连接软件就可以进行平等、对等的连接通信。</li></ul></li><li><p>核心部分：大量的网络与连接这些网络所使用的路由器构成，为边缘部分提供服务（提供连通性和交换）</p><p>​ 核心部分起到特殊作用的是路由器，它是一个专用的计算机（但是不叫主机）。路由器是实现**分组交换（packet switching）**的关键组件，其任务是转发收到的分组（<strong>存储转发</strong>），这是网络核心部分最重要的功能。</p><ul><li><p>电路交换：使用在电话机之间的通信，使用电话交换机解决了多个电话机之间通信需要大量的电线的问题。电路交换的过程是：建立连接(开始占用通信资源)—通话(一直占用通信资源)&mdash;-释放连接(归还通信资源)。电路交换的特点是：通话期间，通话的两个用户会始终占用通信资源。使用电路交换传输计算机数据时，传输效率往往会很低。因为计算机数据具有突变式的特点，线路上真正用来传输数据的时间往往不到10%,大部分通信线路资源绝大部分时间都被浪费了。整个报文的比特流连续的从源点直达终点</p></li><li><p>分组交换：采用存储转发的技术，把一个报文（需要发生出去的整块数据）划分成几组分组后再进行传输。将报文划分成更小的等长数据段，然后加上首部(包含一些控制信息)，构成了一个分组，分组的首部称为一个包头。单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.jpg alt></p></li><li><p>报文交换：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p></li></ul></li></ul><h2 id=2计算机网络的常见硬件设备介绍>2.计算机网络的常见硬件设备介绍：</h2><ul><li><p>物理层：实现网络互连的主要设备有中继器和HUB(集线器)。中继器的主要功能是对接收到的信号进行再生整形放大以扩大网络的传输距离；集线器在此基础上将所有的节点集中在以它为中心的节点中，可组成星型拓扑结构。</p></li><li><p>数据链路层：实现网络互联的主要设备有二层交换机和网桥。交换机是一种基于MAC识别，能完成封装转发数据包功能的网络设备。它可以“学习”MAC地址，并把其存放在内部地址表中，当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口。 交换机将局域网分为多个冲突域，每个冲突域都是有独立的宽带，因此大大提高了局域网的带宽。网桥是数据链路层互联的设备，在网络互联中可起到数据接收、地址过滤与数据转发的作用，可用来实现多个不同网络系统之间的数据交换。</p></li><li><p>网络层：实现网络互连的主要设备有三层交换机和路由器。路由器用于连接多个逻辑上分开的网络，具有判断网络地址和选择IP路径的功能，它能在多网络互联环境中，建立灵活的连接，可用完全不同的数据分组和介质访问方法连接各种子网。</p></li><li><p>传输层（包括传输层）以上：实现网络互连的设备有网关。网关在网络层以上实现网络互连，用于两个高层协议不同的网络互连。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。</p></li></ul><h2 id=3计算机网络体系结构>3.计算机网络体系结构</h2><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB.jpg alt></p><h3 id=31-物理层physical-layer>3.1. 物理层（Physical Layer）</h3><ul><li>OSI模型的最低层或第一层，规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性，为上层协议提供了一个传输数据的物理媒体。</li><li>在这一层，协议数据单元为 <strong>比特（bit）</strong>。</li><li>在物理层的互联设备包括：**集线器（Hub）、中继器（Repeater）**等。</li></ul><h3 id=32-数据链路层datalink-layer>3.2. 数据链路层（Datalink Layer）</h3><ul><li><p>OSI模型的第二层，它控制网络层与物理层之间的通信，其主要功能是在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p></li><li><p>在这一层，协议数据单元为 <strong>帧（frame）</strong>。</p></li><li><p>在数据链路层的互联设备包括：**网桥（Bridge）、交换机（Switch）**等。</p></li><li><p>基本单位：比特流0和1</p></li><li><p>特性：</p><ol><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置，等。平时常见的各种规格的接插件都有严格的标准化的规定。</li><li>电气特性：在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：指明某条线上出现的某一电平的电压的意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li></ol></li><li><p>调制</p></li><li><p>信道</p><p>概念：一般都是用来表示某一个方向传送信息的媒体。</p><p>信道的极限容量</p></li><li><p>传输媒体</p></li><li><p>通道（信道）：</p><ol><li>单向通道（单工通道）：只有一个方向通信，没有反方向交互，如广播。</li><li>双向交替通信（半双工通信）：通信双方都可发消息，但不能同时发送或接收。</li><li>双向同时通信（全双工通信）：通信双方可以同时发送和接收信息</li></ol></li><li><p>通道（信道）复用技术：</p><ol><li>频分复用（FDM，Frequency Division Multiplexing）：不同用户在不同频带，所用用户在同样时间占用不同带宽资源</li><li>时分复用（TDM，Time Division Multiplexing）：不同用户在同一时间段的不同时间片，所有用户在不同时间占用同样的频带宽度</li><li>波分复用（WDM，Wavelength Division Multiplexing）：光的频分复用</li><li>码分复用（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信</li></ol></li></ul><h3 id=33-网络层network-layer>3.3. 网络层（Network Layer）</h3><ul><li>OSI模型的第三层，其主要功能是将网络地址翻译成对应的物理地 ，并决定如何将数据从发送方路由到接收方。该层的作用包括：对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能。</li><li>在这一层，协议数据单元为 <strong>数据包（packet）</strong>。</li><li>在网络层的互联设备包括：**路由器（Router）**等。</li></ul><h3 id=34-传输层transport-layer>3.4. 传输层（Transport Layer）</h3><ul><li>OSI模型中最重要的一层，是第一个端到端，即主机到主机的层次。其主要功能是负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</li><li>在这一层，协议数据单元为 <strong>数据段（segment）</strong>。</li><li>传输层协议的代表包括：TCP、UDP、SPX等。</li></ul><h4 id=341-tcptransmission-control-protocol传输控制协议>3.4.1 TCP（Transmission Control Protocol，传输控制协议）</h4><p>​ TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议</p><h5 id=tcp报文段的首部格式>TCP报文段的首部格式</h5><p>​ TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP 的全部功能都体现在它首部中各字段的作用。因此，只有弄清TCP首部各字段的作用才能掌握TCP的工作原理。下面讨论TCP报文段的首部格式。</p><p>​ TCP报文段首部的前20个字节是固定的，后面有4n字节是根据需要而增加的选项（n是整数)。因此TCP首部的最小长度是20字节。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%9A%84%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png alt></p><ul><li><p>源端口：范围 0~65525</p></li><li><p>目的端口：范围 0~65525</p></li><li><p>序号（sequence number）：TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</p></li><li><p>确认号（acknoledgement number）：期望收到对方的下一个报文段的数据的第一个字节的序号。</p></li><li><p>数据偏移：TCP报文段的数据起始处距离TCP报文段的起始处有多远。这个字段实际上是指出TCP报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。但应注意，“数据偏移”的单位是32位字（即以4字节长的字为计算单位)。由于4位二进制数能够表示的最大十进制数字是15，因此数据偏移的最大值是60字节，这也是TCP首部的最大长度（即选项长度不能超过40字节)。</p></li><li><p>保留</p></li><li><p>6个控制位</p><ol><li><p><strong>URG（URGent）</strong>：当URG =1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据)，而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令(Control + C)。如果不使用紧急数据，那么这两个字符将存储在接收TCP的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了许多时间。</p><p>​ 当URG置1时，发送应用进程就告诉发送方的 TCP有紧急数据要传送。于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针(Urgent Pointer)字段配合使用。</p><p>​ 然而在紧急指针字段的具体实现上，由于过去的有些文档有错误或有不太明确的地方，因而导致对有关的RFC文档产生了不同的理解。于是，在2011年公布的建议标准 RFC6093，把紧急指针字段的使用方法做出了更加明确的解释，并更新了几个重要的RFC 文档，如 RFC793,RFC 1011,RFC 1122等。</p></li><li><p><strong>ACK（ACKnowledgment）</strong>：仅当ACK =1时确认号字段才有效。当ACK = 0时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK置1。</p></li><li><p><strong>PSH（PuSH）</strong>：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送(push)操作。这时，发送方TCP把 PSH 置1，并立即创建一个报文段发送出去。接收方TCP收到PSH =1的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。</p></li><li><p><strong>RST（ReSeT）</strong>：当RST = 1时，表明TCP 连接中出现严重差错（如由于主机崩溃或其他原因)，必须释放连接，然后再重新建立运输连接。RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位。</p></li><li><p><strong>SYN（SYNchronization）</strong>：在连接建立时用来同步序号。当SYN=1而ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使SYN= 1和ACK = 1。因此，SYN置为1就表示这是一个连接请求或连接接受报文。</p></li><li><p><strong>FIN（FINis）</strong>：用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。</p></li></ol></li><li><p>窗口大小：窗口值是[0,216- 1]之间的整数。<strong>窗口指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口)</strong>。窗口值告诉对方:从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位)。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据。</p><p>​ 例如，发送了一个报文段，其确认号是701，窗口字段是1000。这就是告诉对方:“从701号算起，我（即发送此报文段的一方）的接收缓存空间还可接收1000个字节数据（字节序号是701~1700)，你在给我发送数据时，必须考虑到这一点。”</p><p>​ 总之，应当记住: <strong>窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着</strong>。</p></li><li><p>检验和</p></li><li><p>紧急指针：紧急指针仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据)。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。</p></li><li><p>选项：长度可变，最长可达40字节。当没有使用“选项“时，TCP的首部长度是20字节。</p></li></ul><h5 id=tcp可靠传输的实现>TCP可靠传输的实现</h5><h5 id=tcp超时重传机制>TCP超时重传机制</h5><h5 id=tcp的流量控制>TCP的流量控制</h5><p>​ 一般说来，我们总是希望数据传输得更快一些。但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制(flow control)就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>​ 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制下面通过图5-22的例子说明如何利用滑动窗口机制进行流量控制。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg alt></p><p>​ 设A向B发送数据。在连接建立时，B告诉了A:“我的接收窗口rwnd= 400”(这里rwnd表示receiver window)。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1(见图中第一个箭头上面的序号seq = 1。图中右边的注释可帮助理解整个过程)。请注意，图中箭头上面大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值。</p><p>​ 我们应注意到，接收方的主机B进行了三次流量控制。第一次把窗口减小到rwnd = 300，第二次又减到rwnd = 100，最后减到rwnd = o，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。我们还应注意到，B向A发送的三个报文段都设置了ACK=1，只有在ACK= 1时确认号字段才有意义。</p><p>​ 现在我们考虑一种情况。在图5-22中，B向A发送了零窗口的报文段后不久，B的接收缓存又有了一些存储空间。于是B向A发送了rwnd = 400的报文段。然而这个报文段在传送过程中丢失了。A一直等待收到B发送的非零窗口的通知，而B也一直等待A发送的数据。如果没有其他措施，这种互相等待的死锁局面将一直延续下去。</p><p>​ 为了解决这个问题，TCP为每一个连接设有一个 **持续计时器(persistence timer) **。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带Ⅰ字节的数据)R，而对方就在确认这个探测报文段时给出了现在的窗口值。如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。如果窗口不是零，那么死锁的僵局就可以打破了。</p><h6 id=糊涂窗口综合症>糊涂窗口综合症</h6><ol><li><p>发送端引起的糊涂窗口综合症</p><p>​ 如果发送端为产生数据很慢的应用程序服务(典型的有telnet应用)，例如，一次产生一个字节。这个应用程序一次将一个字节的数据写入发送端的TCP的缓存。如果发送端的TCP没有特定的指令，它就产生只包括一个字节数据的报文段。结果有很多41字节的IP数据报就在互连网中传来传去。</p><p>​ 解决的方法是防止发送端的TCP逐个字节地发送数据。必须强迫发送端的TCP收集数据，然后用一个更大的数据块来发送。发送端的TCP要等待多长时间呢？如果它等待过长，它就会使整个的过程产生较长的时延。如果它的等待时间不够长，它就可能发送较小的报文段。Nagle找到了一个很好的解决方法，发明了<a href="https://baike.baidu.com/item/Nagle%e7%ae%97%e6%b3%95/5645172?fromModule=lemma_inlink" target=_blank rel=noopener>Nagle算法</a>
。</p></li><li><p>接收端引起的糊涂窗口综合症</p><p>​ 接收端的TCP可能产生糊涂窗口综合症，如果它为消耗数据很慢的应用程序服务，例如，一次消耗一个字节。假定发送应用程序产生了1000字节的数据块，但接收应用程序每次只吸收1字节的数据。再假定接收端的TCP的输入缓存为4000字节。发送端先发送第一个4000字节的数据。接收端将它存储在其缓存中。缓存满了。它通知窗口大小为零，这表示发送端必须停止发送数据。接收应用程序从接收端的TCP的输入缓存中读取第一个字节的数据。在入缓存中有了1字节的空间。接收端的TCP宣布其窗口大小为1字节，这表示正渴望等待发送数据的发送端的TCP会把这个宣布当作一个好消息，并发送只包括一个字节数据的报文段。这样的过程一直继续下去。一个字节的数据被消耗掉，然后发送只包含一个字节数据的报文段。</p><p>对于这种糊涂窗口综合症，即应用程序消耗数据比到达的慢，有两种建议的解决方法。</p><ul><li><p>Clark解决方法</p><p>​ Clark解决方法是只要有数据到达就发送确认，但宣布的窗口大小为零，直到或者缓存空间已能放入具有最大长度的报文段，或者缓存空间的一半已经空了。</p></li><li><p>延迟确认</p><p>​ 这表示当一个报文段到达时并不立即发送确认。接收端在确认收到的报文段之前一直等待，直到入缓存有足够的空间为止。延迟的确认防止了发送端的TCP滑动其窗口。当发送端的TCP发送完其数据后，它就停下来了。这样就防止了这种症状。迟延的确认还有另一个优点：它减少了通信量。接收端不需要确认每一个报文段。但它也有一个缺点，就是迟延的确认有可能迫使发送端重传其未被确认的报文段。可以用协议来平衡这个优点和缺点，例如定义了确认的延迟不能超过500毫秒。</p></li></ul></li></ol><h5 id=tcp的拥塞控制>TCP的拥塞控制</h5><p>​ TCP的拥塞控制的算法有四种，即慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h6 id=慢开始和拥塞避免>慢开始和拥塞避免</h6><p>​ 下面讨论的拥塞控制也叫做基于窗口的拥塞控制。为此，发送方维持-一个叫做拥塞窗cwnd (congestion window)的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。</p><p>​ 发送方控制拥塞窗口的原则是:只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</p><p>​ 发送方又是如何知道网络发生了拥塞呢﹖我们知道，当网络发生拥塞时，路由器就要丢弃分组。因此只要发送方没有按时收到应当到达的确认报文，也就是说，只要出现了超时，就可以猜想网络可能出现了拥塞。现在通信线路的传输质量一般都很好，因传输出差错而丢弃分组的概率是很小的（远小于1%)。因此，判断网络拥塞的依据就是出现了超时。</p><p>​ 发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><ol><li><p>慢开始</p><ol><li><p>当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。</p><p>​ 在一开始发送方先设置cwnd= 1，发送第一个报文段M1，接收方收到后确认M1。发送方收到对M1的确认后，把 cwnd 从1增大到2，于是发送方接着发送 M2和M3两个报文段。接收方收到后发回对M2和 M3的确认。发送方每收到一个对新报文段的确认（重传的不算在内）就使发送方的拥塞窗口加1，因此发送方在收到两个确认后，cwnd就从2增大到4，并可发送M4~M7共4个报文段（见图5-24)。因此使用慢开始算法后，每经过一个传输轮次(transmission round)，拥塞窗口cwnd就加倍。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%85%A2%E5%BC%80%E5%A7%8B.png alt></p><p>​ 每经过一个传输轮次，拥塞窗口cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过<strong>传输轮次</strong>更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p><p>​ 慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd= 1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况)，然后再逐渐增大cwnd。这当然比设置大的cwnd值一下子把许多报文段注入到网络中要“慢得多”。这对防止网络出现拥塞是一个非常好的方法。</p><p>​ <strong>顺便指出，图5-24只是为了说明慢开始的原理。在TCP 的实际运行中，发送方只要收到一个对新报文段的确认，其拥塞窗口cwnd就立即加1，并可以立即发送新的报文段，而不需要等这个轮次中所有的确认都收到后（如图5-24所示的那样）再发送新的报文段。</strong></p><p>​ 为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh，后面还要讲)。慢开始门限ssthresh 的用法如下:</p><ul><li>当cwnd &lt; ssthresh 时，使用上述的慢开始算法。</li><li>当cwnd > ssthresh时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd = ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></li></ol></li><li><p>拥塞避免算法</p><p>​ 拥塞避免算法的思路是让拥塞窗口cwnd 缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd 加 10，而不是像慢开始阶段那样加倍增长。因此在拥塞避免阶段就有“加法增大”AI (Additive Increase)的特点。这表明在拥塞避免阶段，拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png alt></p><p>​ 上图拥塞控制的过程：</p><ol><li><p>当TCP连接进行初始化时，把拥塞窗口cwnd置为1。为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd = 16</p></li><li><p>在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd=16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长</p></li><li><p>假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd=ssthresh=12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小</p></li><li><p>当拥塞窗口 cwnd = 16时（图中的点4)，出现了一个新的情况，就是发送方一连收到3个对同一个报文段的重复确认（图中记为3-ACK)。关于这个问题要解释如下：</p><p>​ 有时，个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口 cwnd 又设置为1，因而降低了传输效率。</p></li></ol></li></ol><h6 id=快重传和快恢复>快重传和快恢复</h6><p>​ 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。如图5-26所示，接收方收到了M1和M2后都分别及时发出了确认。现假定接收方没有收到M3但却收到了M4。本来接收方可以什么都不做。但按照快重传算法，接收方必须立即发送对M2的重复确认，以便让发送方及早知道接收方没有收到报文段M3;。发送方接着发送M5和 M6,。接收方收到后也仍要再次分别发出对M2的重复确认。这样，发送方共收到了接收方的4个对M2的确认，其中后3个都是重复确认。快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段 M3，因而应当立即进行重传（即“快重传”)，这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BF%AB%E9%87%8D%E4%BC%A0.png alt></p><p>​ 因此，在图5-25中的点4，发送方知道现在只是丢失了个别的报文段。于是不启动慢开始，而是执行<strong>快恢复算法</strong>。这时，发送方调整门限值ssthresh = cwnd / 2 = 8，同时设置拥塞窗口 cwnd = ssthresh =8（见图5-25中的点5)，并开始执行拥塞避免算法。</p><h5 id=tcp的运输连接管理>TCP的运输连接管理</h5><h6 id=三次握手three-way-handshake>三次握手（three-way handshake）</h6><p>TCP建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个TCP报文段。（三次握手three-way handshake）</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg alt></p><p><strong>刚开始客户端处于 <code>Closed</code> 的状态，而服务端处于 <code>Listen</code> 状态</strong>：</p><blockquote><p><code>CLOSED </code>：没有任何连接状态</p><p><code>LISTEN </code>：侦听来自远方 TCP 端口的连接请求</p></blockquote><p><strong>1）第一次握手</strong>：客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 <code>SYN_Send</code> 状态。</p><blockquote><p><code>SYN-SENT</code> ：在发送连接请求后等待匹配的连接请求</p></blockquote><p><strong>2）第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，此时服务器处于 <code>SYN_REVD</code> 的状态。</p><blockquote><p><code>SYN-RECEIVED</code>：在收到和发送一个连接请求后等待对连接请求的确认</p></blockquote><p><strong>3）第三次握手</strong>：客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），此时客户端处于 <code>Establised</code> 状态。</p><p>服务器收到 ACK 报文之后，也处于 <code>Establised 状态</code>，至此，双方建立起了 TCP 连接。</p><blockquote><p><code>ESTABLISHED</code> （established-əˈstabliSHt）：代表一个打开的连接，数据可以传送给用户</p></blockquote><h6 id=四次挥手>四次挥手</h6><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png alt></p><p>刚开始双方都处于<code>ESTABLISHED</code> 状态，假设是客户端先发起关闭请求。四次挥手的过程如下：</p><p><strong>1）第一次挥手</strong>：客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。并<strong>停止再发送数据，主动关闭 TCP 连接</strong>。此时客户端处于 <code>FIN_WAIT1</code> 状态，等待服务端的确认。</p><blockquote><p><code>FIN-WAIT-1</code> - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；</p></blockquote><p><strong>2）第二次挥手</strong>：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 <code>CLOSE_WAIT</code> 状态。</p><blockquote><p><code>CLOSE-WAIT</code> - 等待从本地用户发来的连接中断请求；</p></blockquote><p><strong>此时的 TCP 处于半关闭状态，客户端到服务端的连接释放</strong>。客户端收到服务端的确认后，进入<code>FIN_WAIT2</code>（终止等待 2）状态，等待服务端发出的连接释放报文段。</p><blockquote><p><code>FIN-WAIT-2</code> - 从远程TCP等待连接中断请求；</p></blockquote><p><strong>3）第三次挥手</strong>：如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。此时服务端处于 <code>LAST_ACK</code> 的状态，等待客户端的确认。</p><blockquote><p><code>LAST-ACK</code> - 等待原来发向远程TCP的连接中断请求的确认；</p></blockquote><p><strong>4）第四次挥手</strong>：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 <strong><code>TIME_WAIT</code> （时间等待）状态</strong>。</p><blockquote><p>2MSL = <code>TIME-WAIT</code> - 等待足够的时间以确保远程TCP接收到连接中断请求的确认；</p></blockquote><p><strong>为什么A在 TIME-WAIT状态必须等待2MSL的时间呢?这有两个理由。</strong></p><ul><li><p>为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN + ACK报文段的确认。B会超时重传这个FIN + ACK报文段，而A就能在2MSL时间内收到这个重传的FIN +ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A 和B都正常进入到CLOSED 状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN + ACK 报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入 CLOSED状态。</p></li><li><p>防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。B只要收到了A发出的确认，就进入CLOSED 状态。同样，B在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。我们注意到，B结束TCP连接的时间要比A早一些。</p></li></ul><h6 id=保活计时器keepalive-timer>保活计时器（keepalive timer）</h6><p>​ 除时间等待计时器外，TCP还设有一个保活计时器(keepalive timer)。设想有这样的情况:客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</p><h5 id=tcp的有限状态机>TCP的有限状态机</h5><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E7%9A%84%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA.jpg alt></p><h4 id=342-udpuser-datagram-protocol用户数据报协议>3.4.2 UDP（User Datagram Protocol，用户数据报协议）</h4><h5 id=概述>概述</h5><p>​ 用户数据报协议UDP只在IP的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及差错检测的功能。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP-1.jpg alt>
​ UDP的主要特点是:</p><ol><li><strong>UDP是无连接的</strong>，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放)，因此减少了开销和发送数据之前的时延。</li><li>UDP使用<strong>尽最大努力交付</strong>，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数)。</li><li><strong>UDP是面向报文的</strong>。发送方的 UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文，如图5-4所示。在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给P层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。</li><li><strong>UDP没有拥塞控制</strong>，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用（如IP电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP正好适合这种要求。</li><li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong>。</li><li><strong>UDP的首部开销小</strong>，只有8个字节，比TCP的20个字节的首部要短。</li></ol><p>虽然某些实时应用需要使用没有拥塞控制的UDP，但当很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此，不使用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。</p><h5 id=udp的首部格式>UDP的首部格式</h5><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F.png alt>
用户数据报UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节(图5-5)，由四个字段组成，每个字段的长度都是两个字节。各字段意义如下:</p><ul><li>源端口：源端口号。在需要对方回信时选用。不需要时可用全0。</li><li>目的端口：目的端口号。这在终点交付报文时必须使用。</li><li>长度：UDP用户数据报的长度，其最小值是8（仅有首部)。</li><li>检验和：检测UDP用户数据报在传输中是否有错。有错就丢弃。</li></ul><p>​ 当运输层从IP层收到UDP 数据报时，就根据首部中的目的端口，把UDP 数据报通过相应的端口，上交最后的终点一&mdash;应用进程。图5-6是UDP基于端口分用的示意图。</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/UDP-2.png alt>
​ 如果接收方UDP发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程)，就丢弃该报文，并由网际控制报文协议ICMP 发送“端口不可达”差错报文给发送方。</p><p>​ 请注意，虽然在 UDP之间的通信要用到其端口号，但由于UDP的通信是无连接的，因此<strong>不需要使用套接字</strong>（TCP之间的通信必须要在两个套接字之间建立连接)。</p><p>​ UDP用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在UDP用户数据报之前增加12个字节的伪首部。所谓“伪首部”是因为这种伪首部并不是UDP用户数据报真正的首部。只是在计算检验和时，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。检验和就是按照这个临时的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。</p><p>​ <strong>UDP计算检验和的方法和计算IP数据报首部检验和的方法相似。但不同的是:IP 数据报的检验和只检验IP数据报的首部，但UDP的检验和是把首部和数据部分一起都检验。</strong></p><h3 id=35-会话层session-layer>3.5. 会话层（Session Layer）</h3><ul><li>OSI模型的第五层，管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。其主要功能是建立通信链接，保持会话过程通信链接的畅通，利用在数据中插入校验点来同步两个结点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。</li></ul><h3 id=36-表示层presentation-layer>3.6. 表示层（Presentation Layer）</h3><ul><li>OSI模型的第六层，应用程序和网络之间的翻译官，负责对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的解密和加密、压缩、格式转换等。</li></ul><h3 id=37-应用层application-layer>3.7. 应用层（Application Layer）</h3><ul><li>OSI模型的第七层，负责为操作系统或网络应用程序提供访问网络服务的接口。术语“应用层”并不是指运行在网络上的某个特别应用程序，应用层提供的服务包括文件传输、文件管理以及电子邮件的信息处理。</li><li>在应用层的互联设备包括：**网关（Gateway）**等。</li><li>文件传输协议FTP（File Transfer Protocol），端口号为21；</li><li>超文本传输协议HTTP（HypertextTransfer Protocol），端口号为80；</li><li>简单网络管理协议SNMP（SimpleNetwork Management Protocol）</li><li>域名服务协议DNS（Domain Name Service）</li><li>网络文件系统NFS（Network File System）</li><li>等&mldr;&mldr;</li></ul><h4 id=超文本传输协议http>超文本传输协议HTTP</h4><h5 id=报文格式>报文格式</h5><p>HTTP有两类报文:</p><p>​ (1)请求报文——从客户向服务器发送请求报文，见图6-12(a)</p><p>​ (2)响应报文—从服务器到客户的回答，见图6-12(b)</p><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84.jpg alt>
​ 由于HTTP是面向文本的(text-oriented)，因此在报文中的每一个字段都是一些ASCII码串，因而各个字段的长度都是不确定的。</p><p>​ HTTP请求报文和响应报文都是由三个部分组成的。可以看出，这两种报文格式的区别就是开始行不同。</p><ul><li>开始行，用于区分是请求报文还是响应报文。在请求报文中的开始行叫做请求行(Request-Line)，而在响应报文中的开始行叫做状态行(Status-Line)。在开始行的三个字段之间都以空格分隔开，最后的“CR”和“LF”分别代表“回车”和“换行”</li><li>首部行，用来说明浏览器、服务器或报文主体的一些信息。首部可以有好几行，但也可以不使用。在每一个首部行中都有首部字段名和它的值，每一行在结束的地方都要有“回车”和“换行”。整个首部行结束时，还有一空行将首部行和后面的实体主体分开。</li><li>实体主体(entity body)，在请求报文中一般都不用这个字段，而在响应报文中也可能没有这个字段。</li></ul><h5 id=请求方法>请求方法</h5><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95.jpg alt></p><h6 id=考点>考点</h6><ol><li><p>get和post的区别</p><p>（在编程中一个<strong>幂等</strong>操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同）</p><ul><li>post请求更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中，get请求的是静态资源，则会缓存，如果是数据，则不会缓存）</li><li>post请求发送的数据更大（get请求有url长度限制，http协议本身不限制，请求长度限制是由浏览器和web服务器决定和设置）</li><li>post请求能发送更多的数据类型（get请求只能发送ASCII字符）</li><li>传参方式不同（get请求参数<strong>一般</strong>通过url传递，post请求<strong>一般</strong>放在request body中传递）</li><li>get请求的是静态资源，则会缓存，如果是数据，则不会缓存</li></ul><p>GET和POST：辩证看100 continue，以及最根本区别：https://github.com/amandakelake/blog/issues/20</p></li></ol><h5 id=状态码>状态码</h5><p>​ 状态行包括三项内容，即 HTTP的版本，状态码，以及解释状态码的简单短语。
​ 状态码(Status-Code)都是三位数字的，分为5大类，原先有33种[RFC 2616]，后来又增加了几种[RFC 6585]。这5大类的状态码都是以不同的数字开头的。</p><ul><li>1xx表示通知信息，如请求收到了或正在进行处理。</li><li>2xx表示成功，如接受或知道了。</li><li>3xx表示重定向，如要完成请求还必须采取进-一步的行动。</li><li>4xx表示客户的差错，如请求中有错误的语法或不能完成。</li><li>5xx表示服务器的差错，如服务器失效无法完成请求。</li></ul><p>下面三种状态行在响应报文中是经常见到的。</p><ul><li>HTTP/1.1 202 Accepted {接受}</li><li>HTTP/1.1 400 Bad Request {错误的请求}</li><li>Http/1.1 404 Not Found {找不到}</li></ul><h2 id=4-考点>4. 考点</h2><ol><li><p>三次握手简要流程</p><p>TCP 三次握手，其实就是建立一个 TCP 连接，客户端与服务器交互需要 3 个数据包。握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。</p><ul><li>第一次握手：客户端发送 <code>SYN</code> 报文，并进入 <code>SYN_SENT</code> 状态，等待服务器的确认；</li><li>第二次握手：服务器收到 <code>SYN</code> 报文，需要给客户端发送 <code>ACK</code> 确认报文，同时服务器也要向客户端发送一个 <code>SYN</code> 报文，所以也就是向客户端发送 <code>SYN + ACK</code> 报文，此时服务器进入 <code>SYN_RCVD</code> 状态；</li><li>第三次握手：客户端收到 <code>SYN + ACK</code> 报文，向服务器发送确认包，客户端进入 <code>ESTABLISHED</code> 状态。待服务器收到客户端发送的 <code>ACK</code> 包也会进入 <code>ESTABLISHED</code> 状态，完成三次握手。</li></ul></li><li><p>为什么 TCP 采用三次握手，二次握手可以吗？</p><ul><li><p>确认双方的收发能力</p><p>TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。</p><ol><li><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：<strong>客户端的发送能力、服务端的接收能力是正常的。</strong></p></li><li><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：<strong>服务端的接收、发送能力，客户端的接收、发送能力是正常的</strong>。不过此时服务器并不能确认客户端的接收能力是否正常。</p></li><li><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：<strong>客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。</strong></p></li></ol></li></ul><p>所以，只有三次握手才能确认双方的接收与发送能力是否正常。</p></li><li><p>什么是半连接队列？</p><p>​ 服务器第一次收到客户端的 <code>SYN</code> 之后，就会处于 <code>SYN_RCVD</code> 状态，此时双方还没有完全建立连接。服务器会把这种状态下请求连接放在一个队列里，我们把这种队列称之为半连接队列。</p><p>​ 当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p></li><li><p>三次握手过程中，可以携带数据吗？</p><p>第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p></li><li><p>TCP 四次挥手</p><ul><li>第一次挥手。客户端发起 <code>FIN</code> 包（FIN = 1）,客户端进入 <code>FIN_WAIT_1</code> 状态。TCP 规定，即使 <code>FIN</code> 包不携带数据，也要消耗一个序号。</li><li>第二次挥手。服务器端收到 <code>FIN</code> 包，发出确认包 <code>ACK</code>（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 <code>CLOSE_WAIT</code> 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 <code>ACK</code> 后，进入了 <code>FIN_WAIT_2</code> 状态。</li><li>第三次挥手。服务器端数据发送完毕后，向客户端发送 <code>FIN</code> 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 <code>LAST_ACK</code> 状态。</li><li>第四次挥手。客户端收到服务器的 <code>FIN</code> 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 <code>TIME_WAIT</code> 状态。注意此时 TCP 连接还没有释放，必须经过 <code>2*MSL</code> 后，才进入 <code>CLOSED</code> 状态。而服务器端收到客户端的确认包 <code>ACK</code> 后就进入了 <code>CLOSED</code> 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。</li></ul></li><li><p>为什么建立连接握手三次，关闭连接时需要是四次呢？</p><p>​ 在 TCP 握手的时候，接收端发送 <code>SYN+ACK</code> 的包是将一个 <code>ACK</code> 和一个 <code>SYN</code> 合并到一个包中，所以减少了一次包的发送，三次完成握手。</p><p>​ 对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 <code>FIN</code> 包与对客户端的 <code>ACK</code> 包合并发送，只能先确认 <code>ACK</code>，然后服务器待无需发送数据时再发送 <code>FIN</code> 包，所以四次挥手时必须是四次数据包的交互。</p></li><li><p>为什么TIME_WAIT 状态需要经过 2MSL 才能返回到 CLOSE 状态</p><p>​ <code>MSL</code> 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 <code>FIN</code> 的确认包 <code>ACK</code> 后，这个 <code>ACK</code> 包是有可能不可达的，服务器端如果收不到 <code>ACK</code> 的话需要重新发送 <code>FIN</code> 包。</p><p>​ 所以客户端发送 <code>ACK</code> 后需要留出 <code>2MSL</code> 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。</p><p>​ 也就是说客户端如果等待 <code>2MSL</code> 时间也没有收到服务器端的重传包 <code>FIN</code>，说明可以确认服务器已经收到客户端发送的 <code>ACK</code>。</p></li><li><p>网络模型</p></li></ol><p><img src=/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB.jpg alt></p><ol><li><p>TCP和UDP有什么区别</p><p>1）连接方面 : TCP面向连接。UDP是无连接的，发送数据之前不需要建立连接</p><p>2）安全方面 : TCP提供可靠的服务，保证传送的数据，无差错，不丢失，不重复，且按序到达。UDP则是尽最大努力交付，不保证可靠交付</p><p>3）传输效率：TCP传输效率相对较低，UDP传输效率高</p></li><li><p>TCP是可靠的连接，它是怎么实现的</p></li></ol><p>​ TCP的连接是基于三次握手，而断开则是四次挥手。为了保障数据不丢失及错误（可靠性），它有报文校验、ACK应答、超时重传(发送方)、失序数据重传（接收方）、丢弃重复数据、流量控制（滑动窗口）和拥塞控制等机制</p><ol start=3><li><p>SYN Flood</p><p>​ SYN Flood 伪造 SYN 报文向服务器发起连接，服务器在收到报文后用 SYN_ACK 应答，此应答发出去后，不会收到 ACK 报文</p><p>​ 若攻击者发送大量这样的报文，会在被攻击主机上出现大量的半连接，耗尽其资源，使正常的用户无法访问，直到半连接超时</p></li><li><p>TCP的粘包和拆包</p><p>​ 程序需要发送的数据大小和TCP报文段能发送MSS（Maximum Segment Size，最大报文长度）是不一样的</p><p>​ 大于MSS时，而需要把程序数据拆分为多个TCP报文段，称之为拆包；小于时，则会考虑合并多个程序数据为一个TCP报文段，则是粘包；其中MSS = TCP报文段长度-TCP首部长度</p></li><li><p>解决粘包和拆包的方法都有哪些</p><p>1）在数据尾部增加特殊字符进行分割</p><p>2）将数据定为固定大小</p><p>3）将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小</p></li></ol></div><footer class=post-footer></footer></article></section></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
<span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id=sidebar class=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>文章目录</li><li class=sidebar-nav-overview data-target=site-overview>站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image src=/img/avatar.jpeg alt=Canon><p class=site-author-name itemprop=name>Canon</p><p class="site-description motion-element" itemprop=description>慢慢走, 慢慢来!</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/post/><span class=site-state-item-count>48</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>14</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>12</span>
<span class=site-state-item-name>标签</span></a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item><a href=https://github.com/MrVWY target=_blank title=GitHub><i class="fa fa-fw fa-github"></i>
GitHub</a></span>
<span class=links-of-author-item><a href=https://github.com/MrVWY/Learn-Note target=_blank title=笔记><i class="fa fa-fw fa-globe"></i>
笔记</a></span></div><div class="tagcloud-of-blogroll motion-element tagcloud-of-blogroll-inline"><div class=tagcloud-of-blogroll-title><i class="fa fa-fw fa-tags"></i>
标签云</div><ul class=tagcloud-of-blogroll-list><li class=tagcloud-of-blogroll-item><a href=/tags/go>Go
<sup>20</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2>路由交换
<sup>6</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/leetcode>Leetcode
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/linux>Linux
<sup>4</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/tcp/ip>Tcp IP
<sup>3</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/c>C
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/js>Js
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/network>Network
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/nginx>Nginx
<sup>1</sup></a></li><li class=tagcloud-of-blogroll-item><a href=/tags/tcp/iplinux>Tcp iplinux
<sup>1</sup></a></li></ul></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#1互联网组成>1.互联网组成</a></li><li><a href=#2计算机网络的常见硬件设备介绍>2.计算机网络的常见硬件设备介绍：</a></li><li><a href=#3计算机网络体系结构>3.计算机网络体系结构</a><ul><li><a href=#31-物理层physical-layer>3.1. 物理层（Physical Layer）</a></li><li><a href=#32-数据链路层datalink-layer>3.2. 数据链路层（Datalink Layer）</a></li><li><a href=#33-网络层network-layer>3.3. 网络层（Network Layer）</a></li><li><a href=#34-传输层transport-layer>3.4. 传输层（Transport Layer）</a></li><li><a href=#35-会话层session-layer>3.5. 会话层（Session Layer）</a></li><li><a href=#36-表示层presentation-layer>3.6. 表示层（Presentation Layer）</a></li><li><a href=#37-应用层application-layer>3.7. 应用层（Application Layer）</a></li></ul></li><li><a href=#4-考点>4. 考点</a></li></ul></nav></div></div></section></div></aside></div></main><footer id=footer class=footer><div class=footer-inner><div class=copyright><span class=copyright-year>&copy; 2021 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=copyright-author>Canon Blog</span></div><div class=vistor-info><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script>
<span class=site-uv><i class="fa fa-user"></i>
<span class=busuanzi-value id=busuanzi_value_site_uv></span></span>
<span class=separator-line>/</span>
<span class=site-pv><i class="fa fa-eye"></i>
<span class=busuanzi-value id=busuanzi_value_site_pv></span></span></div><div class=license-info><span class=storage-info>Storage by
<a href style=font-weight:700 target=_blank></a></span>
<span class=separator-line>/</span>
<span class=license-num><a href target=_blank></a></span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i>
<span id=scrollpercent><span>0</span>%</span></div></div><script type=text/javascript src=//unpkg.com/jquery@2.1.4/dist/jquery.min.js></script>
<script type=text/javascript src=/js/search.js></script>
<script type=text/javascript src=/js/affix.js></script>
<script type=text/javascript>function detectIE(){var e=window.navigator.userAgent,t=e.indexOf("MSIE "),n=e.indexOf("Trident/"),s=e.indexOf("Edge/");return t>0||n>0||s>0?-1:1}function getCntViewHeight(){var t=$("#content").height(),e=$(window).height(),n=t>e?t-e:$(document).height()-e;return n}function getScrollbarWidth(){var e=$("<div />").addClass("scrollbar-measure").prependTo("body"),t=e[0],n=t.offsetWidth-t.clientWidth;return e.remove(),n}function registerBackTop(){var t=50,e=$(".back-to-top");$(window).on("scroll",function(){e.toggleClass("back-to-top-on",window.pageYOffset>t);var s=$(window).scrollTop(),o=getCntViewHeight(),i=s/o,n=Math.round(i*100),a=n>100?100:n;$("#scrollpercent>span").html(a)}),e.on("click",function(){$("html,body").animate({scrollTop:0,screenLeft:0},800)})}function initScrollSpy(){var e=".post-toc",s=$(e),t=".active-current";s.on("activate.bs.scrollspy",function(){var t=$(e+" .active").last();n(),t.addClass("active-current")}).on("clear.bs.scrollspy",n),$("body").scrollspy({target:e});function n(){$(e+" "+t).removeClass(t.substring(1))}}function initAffix(){var e=$(".header-inner").height(),t=parseInt($(".footer").outerHeight(!0),10),n=e+10;$(".sidebar-inner").affix({offset:{top:n,bottom:t}})}function initTOCDimension(){$(window).on("resize",function(){e&&clearTimeout(e),e=setTimeout(function(){var e=document.body.clientHeight-100;updateTOCHeight(e)},0)}),updateTOCHeight(document.body.clientHeight-100);var e,t=getScrollbarWidth();$(".post-toc").css("width","calc(100% + "+t+"px)")}function updateTOCHeight(e){e=e||"auto",$(".post-toc").css("max-height",e)}$(function(){var e,t,n,s,o=$(".header-inner").height()+10;$("#sidebar").css({"margin-top":o}).show(),t=parseInt($("#sidebar").css("margin-top")),n=parseInt($(".sidebar-inner").css("height")),e=t+n,s=$(".content-wrap").height(),s<e&&$(".content-wrap").css("min-height",e),$(".site-nav-toggle").on("click",function(){var e=$(".site-nav"),o=$(".toggle"),t="site-nav-on",i="toggle-close",n=e.hasClass(t),a=n?"slideUp":"slideDown",s=n?"removeClass":"addClass";e.stop()[a]("normal",function(){e[s](t),o[s](i)})}),registerBackTop(),initAffix(),initTOCDimension(),$(".sidebar-nav-toc").click(function(){$(this).addClass("sidebar-nav-active"),$(this).next().removeClass("sidebar-nav-active"),$("."+$(this).next().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)}),$(".sidebar-nav-overview").click(function(){$(this).addClass("sidebar-nav-active"),$(this).prev().removeClass("sidebar-nav-active"),$("."+$(this).prev().attr("data-target")).toggle(500),$("."+$(this).attr("data-target")).toggle(500)})})</script><script src=//unpkg.com/imageviewer@1.1.0/dist/viewer.min.js></script>
<script type=text/javascript>$(function(){$(".post-body").viewer()})</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_SVG"></script>
<script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=Your%20AddthisId"></script>
<script>(function(){var t,e=document.createElement("script"),n=window.location.protocol.split(":")[0];n==="https"?e.src="https://zz.bdstatic.com/linksubmit/push.js":e.src="http://push.zhanzhang.baidu.com/push.js",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>