---
title: "Copy-on-write"
date: "2020-06-28 12:22:46"
toc: true
math: true
type: about
---

最近在看到了一种Copy-on-write(写时复制，COW)的技术，因此在这做一下记录
<!-- more -->
### 概念

根据Wikipedia和StackOverflow上面的描述，COW是一种计算机资源管理方面的优化技术，目前我所了解到用到的地方有redis持久化、docker的AUFS文件系统等。

### 过程

目前有一个数据块A，进程1、2、3、4都想访问数据块A，这时候进程1234都是以只读的方式去读取数据A。在cow中，比如进程2想要修改数据块A，这时候触发cow的机制，此时数据块A会被复制一份（这里为了方便区别我们称为数据块B）出来给进程2修改（注意这时候已经有2份数据块A分布在2个不同的内存地址中），而其他进程134不会受到任何影响仍在读取数据块A，而进程2现在在读取数据块B。

### Linux的Copy-on-write

linux的cow主要是在进程方面，主要涉及fork()和exec()，通过fork产生一个子进程。传统的fork会把父进程的所有资源（代码段、数据段、堆、栈）都copy一份给子进程，而使用了cow机制的fork不会复制整个父进程的资源，而是父进程和子进程都共用一个资源，只有当子进程需要写入数据时，才会复制一份给子进程，在此之前都是以只读方式来共享资源。

### redis的Copy-on-write

redis的写时复制主要在其持久化这里，当redis要执行持久化时，其会fork一个子进程来从内存中读取数据，写到磁盘上。如果这时候redis要更新数据或者写操作，那么就会触发cow，开辟一个新的内存块让更新的数据存放。当然如果子进程存在期间发生大量的更新或者写操作，那么此时机子很可能将耗费比较多的性能在copy的操作上。附：[《Redis设计与实现》](http://origin.redisbook.com/index.html)

### 总结

对于Copy-on-write，主要还是要理解其思想，下面是摘录自Wikipedia的概括： 其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被建立，因此多个调用者只是读取操作时可以共享同一份资源。